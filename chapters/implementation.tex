%Implementation

\chapter{Описание практической части}\label{Implementation}

В результате рассуждений, приведенных в предыдущей главе, были приняты следующие решения касательно программной реализации (далее реализации):

\begin{itemize}
	\item Реализация будет представлять собой дополнение к браузеру Mozilla Firefox, написанное на языке JavaScript.
	\item В качестве промежуточного звена между браузером и реализацией будет выступать средство SlimerJS.
	\item Анализ кода будет осуществляться с применением метода taint-анализа.
\end{itemize}

\section{Алгоритм работы}
Не вдаваясь в детали, алгоритм работы реализации можно проиллюстрировать следующей блок-схемой:

\begin{figure}
	\caption{Алгоритм работы программной реализации}
	\includegraphics[width=\textwidth]{images/algorithm.png}
\end{figure}
\newpage


\section{Архитектура программной реализации}
Архитектура программной реализации представлена на рисунке ниже. Краткое описание каждого из модулей будет дано далее.

\bigskip
\begin{figure}[h]
	\caption{Архитектура программной реализации}
	\includegraphics[width=\textwidth]{images/solution_scheme.png}
\end{figure}
\bigskip

В предлагаемой реализации существуют два контекста выполнения JavaScript-кода: \textit{контекст веб-страницы} и \textit{контекст приложения}. Связующими звеньями между двумя контекстами являются веб-браузер и SlimerJS.

\section{Контекст веб-страницы}
\textit{Контекст веб-страницы} содержит код веб-страницы (возможно измененный) и дополнительные модули, которые в него встраиваются. Весь его код исполняется в интерпретаторе браузера. 

\subsection{Модуль Tainter}
	%TODO ссылка на Реализацию Тейнтирования
	В текущей реализации в код веб-страницы встраивается только один модуль, а именно модуль \textit{Tainter}. Его задача заключается в нанесении меток на объекты и в отслеживании помеченных объектов. Для этого он предоставляет интерфейс, содержащий метод \textit{taint(object)}, который и помечает объект. Авторами были созданы две реализации данного метода, которые будут подробно рассмотрены ниже в секции Реализация тейнтирования.

\section{Веб-браузер}
В предлагаемой реализации веб-браузер решает следующие задачи:

\begin{enumerate}
	\item Загрузка и обработка веб-страницы.
	\item Создание контекста веб-страницы.
	\item Исполнение кода веб-страницы.
	% TODO ссылка на модуль Debugger
	\item Предоставление средств отладки исполняемого кода контексту приложения (о средствах отладки будет подробнее рассказано в секции Модуль Debugger).
\end{enumerate}

\section{SlimerJS}
\textit{SlimerJS} является связующим звеном между веб-браузером и контекстом приложения. Он предоставляет удобный интерфейс для передачи запросов от контекста приложения (запрос на загрузку веб-страницы) к веб-браузеру и для информирования контекста приложения о событиях, произошедших в браузере (например, завершение загрузки веб-страницы).

\section{Контекст приложения}

\textit{Контекст приложения} содержит модули, выполняющие основную работу по анализу кода. Кратко опишем работу главных из них.

\subsection{Модуль Tracker}
	Модуль \textit{Tracker} является главным координационным модулем всего приложения. Он отвечает за следующие действия:


	\begin{enumerate}
		\item Инициализация контекста веб-страницы.
		\item Отслеживание создания HTML-элемента.
		\item Выполнение отладочного кода в контексте веб-страницы.
		\item Вывод полученных результатов.
	\end{enumerate}

\subsection{Модуль Debugger}
	Модуль \textit{Debugger} использует интерфейс Debugger-API \cite{debuggerapi}, предоставляемый браузером Mozilla Firefox. Его основная задача заключается в предоставлении средств отладки кода веб-страницы.


	В предлагаемой реализации данный интерфейс используется для двух целей:


	\begin{enumerate}
		\item Модификация кода веб-страницы.
		\item Выполнение отладочного кода в контексте веб-страницы.
	\end{enumerate}

\subsection{Модуль Rewriter}
	% TODO ссылка на переписывание кода
	Как будет показано ниже, для достижения некоторых целей приходится динамически инструментировать код веб-страницы. Для этого используется модуль \textit{Rewriter}. О целях и стратегии инструментирования операторов языка JavaScript будет рассказано далее.

\section{Реализация тейнтирования}
Как уже говорилось выше, в качестве метода анализа кода был выбран метод тейнтирования. В рамках рассматриваемой задачи единственным истоком является контролируемый HTML-элемент. Стоками же являются все объекты, которые были помечены во время выполнения кода.


Рассмотрим список операций \cite{miller}, которые распространяют пометки, то есть операций, результаты которых всегда помечаются:


\begin{enumerate}
	\item Присваивание с помеченной правой частью:
		\begin{lstlisting}
			var x = taint('foo')
		\end{lstlisting}
	\item Доступ к свойству помеченного объекта: 
		\begin{lstlisting}
			var tainted_obj = {'foo': 'bar'}; 
			var x = tainted_obj.foo; 
		\end{lstlisting}
	\item Вызов функций с помеченными аргументами:
		\begin{lstlisting}
			var x = func(taint('foo'), 'bar');
		\end{lstlisting}
	\item Вызов помеченных функций от любых аргументов:
		\begin{lstlisting}
			taint(func);
			var x = func('foo', 'bar');
		\end{lstlisting}
	\item Результат выражений с участием помеченных объектов:
		\begin{lstlisting}
			var x = taint('foo') + 'bar';
		\end{lstlisting}
\end{enumerate}


Авторами были написаны две реализации метода taint(), о которых и пойдет речь далее.

\subsection{Тейнтирование с помощью proxy объектов}
	Первая реализация опиралась на использование так называемых прокси-объектов (proxy). Прокси - это объекты, являющиеся обертками над другими объектами (мы будем называть их внутренними). Задача прокси заключается в перехвате различных событий, связанных с внутренними объектами. В качестве реализации прокси-объектов использовался глобальный объект Proxy \cite{proxy} из стандарта языка JavaScript ECMAScript 6.

	
	Из всего множества событий, перехватываемых Proxy, в работе пригодились следующие:
	

	\begin{itemize}
		\item get: событие для операций \textit{tainted.x} и \textit{tainted['x']}.
		\item set: событие для операций \textit{tainted.x = y} и \textit{tainted['x'] = y}.
		\item apply: событие для операции \textit{tainted(arguments)}.
	\end{itemize}


	Суть метода \textit{taint(object)} заключалась в замене объектов, которые нужно пометить, на прокси, обернутые вокруг них. Например, когда нужно было вернуть значение некоторого свойства помеченного объекта, возвращалось не само значение, а прокси. С помощью такого подхода легко решались проблемы, связанные с распространением пометок в следующих операциях:
	

	\begin{itemize}
		\item Присваивание с помеченной правой частью.
		\item Доступ к свойству помеченного объекта.
		\item Вызов функций с помеченными аргументами.
		\item Вызов помеченных функций от любых аргументов.
	\end{itemize}


	К сожалению, такой подход не даёт возможности перехватывать операции последнего типа (с участием помеченных объектов), поэтому эту задачу пришлось решать с помощью инструментирования операторов.


	В процессе разработки возникли и другие проблемы, связанными с использованием Proxy:


	\begin{itemize}
		\item Proxy объект нельзя обернуть вокруг примитивных значений (string, number, boolean).
		\item Proxy объект обязан возвращать то же значение для неконфигурируемых и защищенных от записи свойств (non-writable non-configurable property).
		\item Некоторые объекты из DOM (например, \textit{document.body}) нельзя заменить на Proxy.
	\end{itemize}


	Первые два ограничения не являются критическими и для них были найдены решения. Третье же показало, что для некоторых имен HTML-элементов программная реализация не соответствует предложенной методике. Рассмотрим данную проблему на примере:

	\begin{lstlisting}
		<form name='querySelector'> </form>
	\end{lstlisting}

	\begin{lstlisting}
		<script>
			document.querySelector = new Proxy(document.querySelector);
		</script>
	\end{lstlisting}

	\begin{lstlisting}
		<form name='body'> </form>
	\end{lstlisting}

	\begin{lstlisting}
		<script>
			document.body = new Proxy(document.body);
		</script>
	\end{lstlisting}

	Результат выполнения кода из первых двух листингов эквивалентен - функция \textit{document.querySelector} заменится другим объектом. Код из третьего листинга также заменит объект \textit{document.body}, а вот в работе кода из четвертого листинга произойдет ошибка.


	Данная проблема ведет к тому, что предложенный алгоритм не будет работать для некоторых имен (например, document.body). Поэтому было принято решение о поиске другой реализации метода taint().

\subsection{Тейнтирование на основе инструментирования кода}
	Второй возможной стратегией тейнтирования является нанесение пометок на сами объекты в виде некоторого специального свойства (\textit{object.is\_tainted = true}). Такой подход хорош тем, что он лишен проблем, связанных с использованием Proxy. Однако, он ставит перед разработчиками новую задачу, а именно, реализацию распространения пометок через операции.


	На момент начала работ над вторым способом тейнтирования уже был написан механизм инструментирования кода, необходимый для замены стандартных операторов языка JavaScript. Было решено использовать этот механизм для переписывания операций на эквивалентные, но с возможностью распространения пометок \cite{rewriting} \cite{rewriting2}. 


	Рассмотрим еще раз список операций, распространяющих пометки, и приведем примеры их переписанных версий:
	\begin{enumerate}
		\item Присваивание с помеченной правой частью:
			\begin{lstlisting}
				var taint = function(object) {
					...
					object.is_tainted = true;
					...
				}
				var x = taint('foo');
			\end{lstlisting}
		\item Доступ к свойству помеченного объекта: 
			\begin{lstlisting}
				var tainted_obj = {'foo': 'bar'}; 
				var x = __get__(tainted_obj, 'foo'); // §вместо§ var x = tainted_obj.foo; 
			\end{lstlisting}
		\item Вызов функций с помеченными аргументами:
			\begin{lstlisting}
				var x = __call__(func, [taint('foo'), 'bar']); // §вместо§ var x = func(taint('foo'), 'bar');
			\end{lstlisting}
		\item Вызов помеченных функций от любых аргументов:
			\begin{lstlisting}
				taint(func);
				var x = __call__(func, ['foo', 'bar']); // §вместо§ var x = func('foo', 'bar');
			\end{lstlisting}
		\item Результат выражений с участием помеченных объектов:
			\begin{lstlisting}
				var x = __add__(taint('foo'), 'bar'); // §вместо§ var x = taint('foo') + 'bar';
			\end{lstlisting}
	\end{enumerate}

	С помощью данного подхода мы получили решение эквивалентное предложенной методике. Расплатой за это явилось увеличение времени выполнения и размера кода веб-страницы.

\section{Реализация инструментирования кода}
Как было показано выше, для достижения поставленных целей необходимо добавление к реализации компонента, способного решать следующие задачи:

\begin{itemize}
	\item Перегрузка оператов (+, -, \&\&, и т. п.)
	\item Перегрузка оператора typeof
	\item Создание геттеров (аксессоров) и сеттеров (мутаторов) для некоторых объектов
	\item Перехват вызовов функций
\end{itemize}


Одним из возможных решений является инструментирования кода. Его суть заключается в замене кода, содержащегося в веб-странице, эквивалентным с точки зрения выполняемой программы кодом, который осуществляет некоторые дополнительные действия.


Приведем наглядный пример таких кодов:

\bigskip
\begin{lstlisting}
	var x = tainted('foo') + 'bar';
\end{lstlisting}


\begin{lstlisting}
	function __add__(left, right) {
		var result = left + right;
		if (is_tainted(left) || is_tainted(right)) {
			taint(result);
		}
		return result;
	}
	var x = tainted('foo') + 'bar';
\end{lstlisting}


Два приведенных кода являются эквивалентными в том смысле, что в переменную \textit{x} запишется результат конкатенации строк \textit{'foo'} и \textit{'bar'}, но в результате второго из них переменная \textit{x} будет помечена.


Аппарат переписывания кода работает следующим образом:


\begin{enumerate}
	\item Построить по данному коду его представление в виде АСД (Абстрактного Синтаксического Дерева).
	\item Обойти дерево в глубину, преобразуя необходимые узлы.
	\item По полученному АСД сгенерировать новый код.
\end{enumerate}


Рассмотрим работу приведенного алгоритма на примере:

\bigskip
\begin{lstlisting}
	var a = 'foo' + 'bar';
\end{lstlisting}


По данному коду будет построено следующее АСД:

\bigskip
\begin{lstlisting}
	{
    "type": "Program",
    "body": [
        {
            "type": "VariableDeclaration",
            "declarations": [
                {
                    "type": "VariableDeclarator",
                    "id": {
                        "type": "Identifier",
                        "name": "x"
                    },
                    "init": {
                        "type": "BinaryExpression",
                        "operator": "+",
                        "left": {
                            "type": "Literal",
                            "value": "foo",
                            "raw": "'foo'"
                        },
                        "right": {
                            "type": "Literal",
                            "value": "bar",
                            "raw": "'bar'"
                        }
                    }
                }
            ],
            "kind": "var"
        }
    ],
    "sourceType": "script"
	}
\end{lstlisting}


После преобразований будет получено следующее АСД:

\bigskip
\begin{lstlisting}
	{
    "type": "Program",
    "body": [
        {
            "type": "VariableDeclaration",
            "declarations": [
                {
                    "type": "VariableDeclarator",
                    "id": {
                        "type": "Identifier",
                        "name": "x"
                    },
                    "init": {
                        "type": "CallExpression",
                        "callee": {
                            "type": "Identifier",
                            "name": "__add__"
                        },
                        "arguments": [
                            {
                                "type": "Literal",
                                "value": "foo",
                                "raw": "'foo'"
                            },
                            {
                                "type": "Literal",
                                "value": "bar",
                                "raw": "'bar'"
                            }
                        ]
                    }
                }
            ],
            "kind": "var"
        }
    ],
    "sourceType": "script"
	}
\end{lstlisting}


По полученному АСД будет сгенерирован следующий код:

\bigskip
\begin{lstlisting}
	var x = __add__('foo', 'bar');
\end{lstlisting}


Реализация аппарата использует следующие библиотеки:

\begin{itemize}
	\item Построение АСД - esprima \cite{esprima}
	\item Обход АСД - estraverse \cite{estraverse}
	\item Генерация кода -  escodegen \cite{escodegen}
\end{itemize}


\section{Тестирование реализации}
\label{tainting}
Тестирование реализации осуществлялось тремя способами:

\subsection{Модульное тестирование} 
	Модульное тестирование позволяет проверить корректность работы отдельных модулей программы. Оно также дает возможность убедиться в том, что код продолжает быть корректным после внесения в него изменений, что существенно сокращает количество времени, необходимого на разработку.


	В предложенной реализации с помощью модульного тестирования проверялась работа следующих компонент:
	\begin{itemize}
		\item \textit{Модуль Tainter} (проверялась корректность распространения пометок операциями)
		\item \textit{Модуль Rewriter} (проверялась корректность инструментирования кода)
	\end{itemize}

\subsection{Синтетические веб-страницы}
	Под синтетическими веб-страницами понимаются страницы, удовлетворяющие следующим критериям (например, набор тестовых страниц  \url{damnvulnerable.me}): 

	\begin{itemize}
		\item В них присутствует недостаток DOM Clobbering
		\item Их код достаточно мал по объему, чтобы его можно было проанализировать вручную
		\item Для них известны способы и результаты эксплуатации
	\end{itemize}


	В процессе тестирования проверялось соответствие результатов, полученных программой, и полученных вручную.

\subsection{Реальные веб-сайты}
	Для проверки работы реализации в реальных условиях использовались веб-сайты, содержащие большое количество JavaScript-кода (например, \url{twitter.com}, \url{reme.io}, \url{phpregex.appspot.com}). В случае отсутствия в странице недостатка DOM Clobbering создавалась её копия с внедренным недостатком. В процессе тестирования проверялось соответствие результатов, полученных программой, и полученных вручную.

