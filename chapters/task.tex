% Task

\chapter{Постановка задачи}\label{Introduction}

\section{Неформальная постановка задачи}

Рассмотрим на небольшом примере причины возникновения недостатка DOM Clobbering.

\bigskip
% TODO пронумеровать листинги
\textbf{Пример 1:}

\begin{lstlisting}[language=HTML]
	<form name="form_name">
	<script>
		var form = document.form_name; // указывает на <form name="form_name">
	</script>
\end{lstlisting}
\bigskip




Для представления содержимого веб-страницы в виде объектов на языке JavaScript веб-браузеры используют технологию DOM (Объектная Модель Документа). В рамках DOM HTML-странице ставится в соответствие объект document, а окну веб-браузера - объект window. После загрузки и обработки страницы эти объекты заполняются различным свойствами (например, document.cookie - объект, представляющий идентификатор сессии пользователя).


% TODO: ссылка на Tangled Web
Так же дело обстоит и с тэгами страницы: после создания HTML элемента он становится доступен по указателям document.element\_name, window.element\_name (верно для элементов одного из типов <img>, <form>, <embed>, <object> и <applet>) и window.element\_id (верно для всех элементов), где element\_name - это имя (атрибут name) созданного элемента, а element\_id - это идентификатор элемента (атрибут id). Однако, в случае, если document.element\_name или window.element\_name указывали на какой-нибудь другой объект, указатель на этот объект заменяется указателем на HTML элемент (неверно для window.element\_id). В этом заключается вся суть эксплуатации недостатка DOM Clobbering: злоумышленник подбирает имя HTML элемента таким образом, чтобы заменить какой-нибудь важный объект в объектной модели документа страницы.

Рассмотрим пару типичных примеров недостатка DOM Clobbering.

\bigskip
\textbf{Пример 2:}


\begin{lstlisting}[language=HTML]
	<form name=“querySelector”>
	<script>
		var element = document.querySelector(“a”); // ошибка: document.querySelector указывает на <form name=“querySelector”
	</script>
\end{lstlisting}
\bigskip

В данном примере пользователь контролирует атрибут name (имя) у формы на странице и изменяет его на “querySelector”. Далее, в коде вызывается вызывается функция document.querySelector, но, так как document.querySelector теперь указывает на HTML форму, которая не является функцией, при таком вызове произойдет ошибка.
То есть, действуя подобным образом, злоумышленник может добиться нарушения работоспособности кода на стороне клиента.

\bigskip
\textbf{Пример 3:}

\begin{lstlisting}[language=HTML]
	<form name=“security_flag”>
	<script>
		if (securityCheck()) {
			security_flag = true;
		}
		if (security_flag) {
			// критически важная с точки зрения безопасности секция кода
		}
	</script>
\end{lstlisting}
\bigskip

В данном примере пользователь контролирует атрибут name (имя) у формы на странице и изменяет его на “security\_flag”. Далее вызывается функция \\securityCheck, суть которой заключается, например, в проверке обладает ли пользователь достаточными правами для выполнения критически важной секции кода. Если пользователь проходит проверку, то глобальной переменной security\_flag присваивается значение true, иначе она остается неинициализированной. Далее, в зависимости от значения переменной security\_flag выполняется или не выполняется некоторый критически важный код. Но, так как пользователь изменил имя формы на “security\_flag”, то во втором условном операторе security\_flag будет указывать на HTML форму, следовательно, критический код будет выполнен даже если пользователь не прошел проверку securityCheck.
Заметим, что данный пример является несколько вырожденным, но он ясно дает понять, что в некоторых случаях злоумышленники могут обойти логику работы кода на стороне клиента с помощью недостатка DOM Clobbering.

\bigskip
\textbf{Пример 4:}

\begin{lstlisting}[language=HTML]
	<a href=“plugins/preview/preview.html#<svg onload=alert(1)>” id=“_cke_htmlToLoad” target=“_blank”>
		Click me!
	</a>

	файл /plugins/preview/preview.html:
	<script>
		...
		document.write(window.opener._cke_htmlToLoad);
		...
	</script>
\end{lstlisting}
\bigskip


% TODO: ссылка на спич Mario
Данный пример взят из работы реального веб-приложения. На одной из его страниц размещалась ссылка (элемент <a>), с идентификатором равным \\
“\_cke\_htmlToLoad”, указывающая на страницу “plugins/preview/preview.html\#<svg onload=alert(1)>”. Далее, после того, как пользователь переходил по этой ссылке, на странице plugins/preview/preview.html отрабатывал код, записывающий строку window.opener.\_cke\_htmlToLoad в конец веб-страницы. Но, так как window.opener указывал на ту страницу, с которой был осуществлен переход на текущую, а в ней \_cke\_htmlToLoad указывал на контролируемый элемент <a>, в конец документа записывалась строка “plugins/preview/preview.html\#<svg onload=alert(1)>”. А дописывание в документ строки <svg onload=alert(1)> означало создание HTML элемента типа <svg>, при завершении загрузки которого выполнялся код alert(1).
Таким образом, злоумышленник получал возможность внедрять и исполнять произвольный код на стороне клиента, что может привести к плохим последствиям.

\section{Терминология предметной области}

% TODO: удалить последний пункт
Введем некоторые определения, используемые далее:
\begin{itemize}
    \item \textbf{DOM} - Document Object Model или Объектная Модель Документа - универсальный интерфейс для представления и взаимодействия с HTML, XHTML и XML документами.
    \item \textbf{Уязвимость} - недостаток веб-приложения, позволяющий злоумышленникам намеренно нарушить его целостность и вызвать его неправильную работу.
    \item \textbf{Клиентская сторона веб-приложения} - исполнимый код, содержащийся в веб-страницах, получаемых от веб-сервера.
   	\item Сюда буду еще дописывать по мере работы.
\end{itemize}

\section{Формальное определение DOM Clobbering}

Используя введенные выше термины дадим формальное определение DOM Clobbering: DOM Clobbering - это недостаток клиентской стороны веб-приложения, заключающийся в подмене объектов (переменных) веб-страницы с помощью изменения имен и/или идентификаторов некоторых HTML элементов на веб-странице.

\section{Постановка задачи}
Сформулировать методику и разработать инструментальное средство для определения возможности (и последствий) подмены объектов DOM для заданной веб-страницы.