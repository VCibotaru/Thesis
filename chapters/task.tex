% Task

\chapter{Постановка задачи}\label{Introduction}

\section{Неформальная постановка задачи}

Рассмотрим на примере причины возникновения недостатка DOM Clobbering.

\bigskip
\textbf{Пример 1:}
\begin{lstlisting}[caption=пример недостатка DOM Clobbering]
	<form name="form_name">
	<script>
		var form = document.form_name; // points to <form name="form_name">
	</script>
\end{lstlisting}
\bigskip




Для представления содержимого веб-страницы в виде объектов на языке Java\-Script веб-браузеры используют интерфейс DOM (Объектная Модель Документа). В рамках DOM HTML-странице ставится в соответствие объект document, а окну веб-браузера - объект window. После загрузки и обработки страницы эти объекты заполняются различным свойствами (например, document.location - объект, содержащий информацию про расположение (URL) документа).


Так же дело обстоит и с тэгами страницы: после создания HTML-элемента <x name='element\_name' id='element\_id'> он становится доступен по указателям document.element\_name, window.element\_name (верно для элементов одного из типов <img>, <form>, <embed>, <object> и <applet>) и window.element\_id (верно для всех элементов), где element\_name - это имя (значение атрибута name) созданного элемента, а element\_id - это идентификатор элемента (значение атрибута id) \cite{TWClobbering}.



Аналогично в пространство имен документа попадают и объекты из JavaScript-кода. Например, в результате загрузки страницы в пространство имен документа добавится выше описанное свойство document.location. То есть, свойства DOM могут заполняться как из контекста JavaScript-кода, так и в результате обработки HTML-элементов.


Такое поведение приводит к тому, что если в пространстве имен документа уже существовал объект document.x и HTML-парсер встречает элемент <form name='x'>, то происходит конфликт имен и document.x начинает указывать на \\HTML-форму. В этом заключается вся суть эксплуатации недостатка DOM Clobber\-ing: злоумышленник подбирает имя HTML-элемента таким образом, чтобы заменить какой-нибудь важный объект в объектной модели документа страницы.


Рассмотрим три типичных примеров недостатка DOM Clobbering.

\bigskip
\textbf{Пример 2:}


\begin{lstlisting}[caption=вызов ошибки]
	<form name="querySelector">
	<script>
		var element = document.querySelector("a"); // error: document.querySelector points to <form name=“querySelector”
	</script>
\end{lstlisting}
\bigskip

В данном примере пользователь путем взаимодействия с приложением может изменять значение атрибута name (имя) у формы на странице и устанавливает его равным “querySelector”. Далее в коде вызывается вызывается функция document.querySelector, но, так как document.querySelector теперь указывает на \\HTML-форму, которая не является функцией, при таком вызове произойдет ошибка.
То есть, действуя подобным образом, злоумышленник может добиться нарушения работоспособности кода на стороне клиента.

\bigskip
\textbf{Пример 3:}

\begin{lstlisting}[caption=обход логики программы]
	<form name="is_in_black_list">
	<script>
		if (user_in_black_list()) {
			is_in_black_list = true;
		}
		if (is_in_black_list) {
			forbid_action();
		}
	</script>
\end{lstlisting}
\bigskip

В данном примере пользователь путем взаимодействия с приложением может изменять значение атрибута name (имя) у формы на странице и устанавливает его равным “is\_in\_black\_list”. Далее вызывается функция \\user\_in\_black\_list, суть которой заключается в проверке находится ли пользователь в черном списке приложения. Если это так, то глобальной переменной \\is\_in\_black\_list присваивается значение true, иначе она остается неинициализированной. Далее, в зависимости от значения переменной is\_in\_black\_list пользователю разрешается или запрещается выполнение какого-нибудь действия. Но, так как имя формы  “is\_in\_black\_list”, то во втором условном операторе is\_in\_black\_list будет указывать на HTML-форму, следовательно, пользователю будет отказано в выполнение действия.
Заметим, что данный пример является несколько вырожденным, но он ясно дает понять, что в некоторых случаях злоумышленники могут обойти логику работы кода на стороне клиента с помощью недостатка DOM Clobbering и тем самым навредить пользователям.

\bigskip
\textbf{Пример 4:}

\begin{lstlisting}[caption=исполнение произвольного кода]
	<a href="plugins/preview/preview.html#<svg onload=alert(1)>" id="_cke_htmlToLoad" target="_blank">
		Click me!
	</a>

	файл /plugins/preview/preview.html:
	<script>
		...
		document.write(window.opener._cke_htmlToLoad);
		...
	</script>
\end{lstlisting}
\bigskip


Данный пример взят из кода реального веб-приложения \cite{mario}. На одной из его страниц размещалась ссылка (элемент <a>) с идентификатором, равным \\
“\_cke\_htmlToLoad”, указывающая на страницу “plugins/preview/preview.html\#<svg onload=alert(1)>”. Далее, после того, как пользователь переходил по этой ссылке, на странице plugins/preview/preview.html отрабатывал код, записывающий строку window.opener.\_cke\_htmlToLoad в конец веб-страницы. Но, так как window.opener указывал на ту страницу, с которой был осуществлен переход на текущую, а в ней \_cke\_htmlToLoad указывал на контролируемый элемент <a>, в конец документа записывалась строка “plugins/preview/preview.html\#<svg onload=alert(1)>”. А дописывание в документ строки <svg onload=alert(1)> означало создание HTML-элемента типа <svg>, при завершении загрузки которого выполнялся код alert(1).
Таким образом злоумышленник получал возможность внедрять и исполнять произвольный код на стороне клиента, что может привести к плохим последствиям.

\section{Модель нарушителя}
В данной работе рассматривается следующая модель нарушителя: \textit{Нарушитель предоставляет жертве (клиенту веб-приложения) ссылку, ведущую на одну из страниц веб-приложения. Клиент, удостоверившись в том, что ссылка ведет на знакомый ему веб-сайт, открывает её в своем веб-браузере. Далее, код веб-страницы обрабатывает параметры, содержащиеся в переданном УРЛ (в случае DOM Clobbering данным параметром будет имя HTML-элемента), что приводит к последствиям, описанным выше}.
\section{Определение DOM Clobbering}

Дадим определение DOM Clobbering: DOM Clobbering - это недостаток клиентской стороны веб-приложения, заключающийся в возможности подмены объектов (переменных) веб-страницы с помощью изменения имен и/или идентификаторов некоторых HTML-элементов на веб-странице.

\section{Цель работы}
Цель данной работы - сформулировать методику и разработать инструментальное средство для определения возможности (и последствий) подмены объектов DOM для заданной веб-страницы, а также провести исследование их применимости.