%Solution

\chapter{Построение решения задачи}\label{Solution}
Опишем процесс построения решения задачи, основанного на предложенной выше методике.

\section{Декомпозиция на подзадачи}
Исходя из предложенной методики, можно очевидным образом разбить процесс построения решения на следующие подзадачи, соответствующие этапам методики:

\begin{itemize}
	\item Задача выбора метода анализа кода на языке JavaScript для определения зависимостей по данным
	\item Задача создания среды для удобного проведения автоматического анализа кода
\end{itemize}

\section{Выбор метода анализа кода}

Итак, первая подзадача, которую нужно решить, - это задача выбора метода анализа кода (далее просто метода). 

\bigskip
Перед методом стоит только одна задача: \textit{проанализировать код заданной веб-страницы и построить для него ГПД (граф потока данных) и список переменных и операторов, которые зависят по данным от заданного HTML элемента.}

\bigskip
Основным критерием выбора метода является \textit{корректность, то есть способность правильно строить ГПД и обнаруживать зависимости.} Все остальные свойства (такие как \textit{скорость работы} или \textit{простота реализации}) не играют столь важной роли, поэтому в данной работе не рассматриваются.

\bigskip
Существует две основные группы методов анализа JavaScript кода: статические и динамические. Рассмотрим их подробнее.

\subsection{Статические методы}
	Под статическими методами анализа кода подразумевается методы, не предполагающие его исполнение. Такие методы работают только с исходным кодом приложения. Рассмотрим ряд особенностей языка JavaScript, затрудняющих применение статического анализа:

	\begin{itemize}
		\item Динамическая типизация
		\item Динамическое исполнения кода (функции eval, и т. п.)
		\item Вызов функций от произвольного числа аргументов
		\item Прототипное наследование
		\item Зависимость значения указателя this от контекста выполнения
	\end{itemize}
	\bigskip

	Приведем пару примеров ситуаций, в которых методы статического анализа могут испытывать трудности:


	\bigskip
	\textbf{Динамическая типизация:}
	\begin{lstlisting}
		var a = 1;
		a = a + 'foo';
		var b = typeof a; // b = 'string'
		if (b === 'string') {
			console.log('a is string');
		}
		else if (b === 'number') {
			console.log('b is number');
		}
	\end{lstlisting}

	\bigskip
	\textbf{Динамическое исполнение кода:}
	\begin{lstlisting}
		eval(atob("YWxlcnQoMSk7")); // эквивалентно alert(1);
	\end{lstlisting}

	\bigskip
	\textbf{Вызов функций от произвольного числа аргументов:}
	\begin{lstlisting}
		var f = function(a) {
			console.log('a is ' + a + ' ;arguments are: ' + arguments);
			
		}
		f(); // a is undefined ;arguments are: {}
		f(1); // a is 1 ;arguments are: {'0': 1}
		f(1, 2); // a is 1 ;arguments are: {'0': 1, '1': 2}
	\end{lstlisting}		

	\bigskip
	\textbf{Прототипное наследование:}
	\begin{lstlisting}
		var Number = function() {
			this.num = 1;
		}
		var a = new Number();
		var b = new Number();
		a.num = 2;
		delete Number.prototype.num;
		console.log(a.num); // 1
		console.log(b.num); // undefined
	\end{lstlisting}	

	\bigskip
	\textbf{Зависимость значения указателя this от контекста выполнения:}
	\begin{lstlisting}
		var obj = {
			message: 'Hello World!'
			sayHello: function() {
				return this.message;
			}
		}
		var f = obj.sayHello;
		obj.sayHello(); // 'Hello World!'
		f(); // undefined
	\end{lstlisting}	


	%TODO списать у Данилы ссылки на исследования (4, 5, 6)
	Описанные выше примеры иллюстрируют (хоть и в упрощенном виде) распространенные практики написания программ на языке JavaScript, которые часто встречаются в реальных веб-приложениях. Они наглядно показывают, что примененяя только методы статического анализа достаточно трудно корректно восстановить потоки данных в коде. Следовательно, применение методов статического анализа нецелесообразно.

\subsection{Динамические методы}
	В отличии от статических методов, динамические методы используют информацию, полученную во время работы программы (такую как, например, значения переменных или список вызванных функций). Из всего множества динамических методов наиболее подходящим для решаемой задачи является метод тейнтирования (также называемый тейнт-анализом, taint analysis). Как будет показано ниже, его основная идея близка к главной идее предложенной методики и позволяет эффективно обнаруживать потоки данных в коде.


	Метод тейнтирования подразумевает выделение в коде двух особых типов объектов:
	\begin{itemize}
		\item \textit{Истоки} - это объекты, через которые в программу попадает недоверенный пользовательский ввод.
		\item \textit{Стоки} - это критически важные с точки зрения безопасности объекты, в которые не должен попасть необработанный пользовательский ввод.
	\end{itemize}

	% TODO ссылку на тейнт
	Основная цель тейнт-анализа - выяснить попадает ли ввод из какого-либо истока в какой-либо сток в необработанном виде. Алгоритм работы метода состоит их трех этапов:

	\begin{itemize}
		\item \textit{Пометка истоков (tainting)} - истоки помечаются особым образом.
		\item \textit{Распространение пометок (propagation)} - при любом взаимодействии с помеченной переменной (присваивании, вызова функций, применение операторов, получение свойств, и т.д.) результат операции помечается.
		\item \textit{Проверка} - проверяется существует ли помеченный сток.
	\end{itemize}


\subsection{Выводы}
	Из-за практической неприменимости методов статического анализа выбор авторов пал на методы динамического анализа, а именно на метод тейнтирования, так как он в идейном плане наиболее близок к предложенной методике.


\section{Создание среды для анализа кода}
Второй решаемой подзадачей является задача создания среды для анализа кода (далее просто среды).

\subsection{Решаемые задачи}
	Здесь под средой подразумевается некоторое вспомогательное средство, которое должно решать следующие задачи:

	\begin{enumerate}
		\item Первичная обработка веб-страницы и (возможное) изменение некоторых ее свойств
		\item Предоставление средству анализа кода интерфейса для доступа к содержимому веб-страницы
		\item Интерпретация кода веб-страницы
	\end{enumerate}

\subsection{Критерии оценки}
	Для оценки различных решений данной подзадачи были выбраны следующие критерии:

	\begin{enumerate}
		\item Простота разработки - среда должна требовать меньшее количество усилий на разработку, чем средство для анализа кода.
		\item Переносимость - среда должна корректно работать на различных компьютерах с различными операционными системами.
		\item Скорость - так как анализ кода является ключевым и достаточно долгим процессом, среда не должна тратить большое количество времени на работу.
		\item Корректность - среда должна обрабатывать веб-страницы идентично тому, как это делают клиентские среды (веб-браузеры).
	\end{enumerate}
	\bigskip

	Авторами были проанализированы два способа создания такой среды, а именно:
	\begin{itemize}
		\item Модификация интерпретатора веб-браузера
		\item Создание дополнения для веб-браузера
	\end{itemize}

\subsection{Модификация интерпретатора}
	%TODO ссылка на SpiderMonkey
	%TODO ссылка на Mozilla
	Данный подход заключается в модификации кода существующего интерпретатора программ на языке JavaScript. Примером является интерпретатор SpiderMonkey с открытым исходным кодом, входящий в состав веб-браузера Mozilla Firefox. 

	Проанализируем данный подход, основываясь на приведенных выше критериях:
	\begin{enumerate}
		\item Простота разработки - для модификации интерпретатора нужно сначала разобраться как он работает, а затем внести в него изменения. Авторам эта задача представляется сравнимой по сложности с задачей создания средства анализа кода.
		\item Переносимость - разработанная таким образом среда будет обладать одним большим недостатком - при выпуске обновлений интерпретатора её нужно будет изменять соответственно.
		\item Скорость - интерпретаторы, входящие в состав веб-браузеров являются хорошо оптимизированными программами, поэтому скорость работы среды будет высокой.
		\item Корректность - разработанная таким образом среда будет работать абсолютно идентично веб-браузеру.
	\end{enumerate}

\subsection{Создание дополнения для веб-браузера}
	%TODO ссылка на SlimerJS
	Современные веб-браузеры предоставляют API (Application Programming Interface, Интерфейс Программирования Приложений), дающие возможность использования функционала браузера. На основе таких API создаются приложения для автоматизации работы с браузерами. Одним из таких приложений является SlimerJS, работающий с Mozilla Firefox. 


	SlimerJS предоставляет возможность решения всех задач, описанных в секции Решаемые Задачи. Проанализируем данный подход, основываясь на приведенных выше критериях:

	\begin{enumerate}
		\item Простота разработки - SlimerJS предоставляет простые и понятные интерфейсы для работы с браузером, освоение которых не занимает много времени.
		\item Переносимость - работа SlimerJS зависит только от уставленного на компьютере браузера Mozilla Firefox, но не от операционной системы.
		\item Скорость - использование SlimerJS будет затормаживать работу всей системы, но, как показали практические эксперименты, падение скорости является незначительным.
		\item Корректность - разработанная таким образом среда будет работать абсолютно идентично веб-браузеру.
	\end{enumerate}

\subsection{Выводы}
	Для наглядного сравнения двух возможных решений, сведем результаты анализа в следующую таблицу:

	\begin{table}[h]
		\centering
		% TODO change caption here
		% \caption{My caption}
		\label{my-label}
	\begin{tabular}{|l|l|l|}
	\hline
	              & Модификация интерпретатора                      & Создание дополнения для веб-браузера \\ \hline
	Простота      & \cellcolor[HTML]{CB0000}                        & \cellcolor[HTML]{32CB00}             \\ \hline
	Переносимость & \cellcolor[HTML]{CB0000}                        & \cellcolor[HTML]{32CB00}             \\ \hline
	Скорость      & \cellcolor[HTML]{32CB00} 						& \cellcolor[HTML]{FFC702}             \\ \hline
	Корректность  & \cellcolor[HTML]{32CB00}                        & \cellcolor[HTML]{32CB00}             \\ \hline
	\end{tabular}
	\end{table}


	Из-за большой сложности первого метода, предпочтение было отдано созданию среды в виде дополнения к веб-браузеру.



